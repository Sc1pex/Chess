\vspace{1cm}
\subsubsection{Implementarea algoritmului}
\vspace{1cm}

Funcția \textit{bot\_move}
\begin{lstlisting}[language=RustHtml]
pub fn bot_move(board: Board, difficulty: Difficulty) -> Move {
    let (depth, tt_size, max_time) = match difficulty {
        Difficulty::Easy => (5, 10000000, 3000),
        Difficulty::Medium => (7, 10000000, 3000),
        Difficulty::Hard => (30, 10000000, 10000),
    };

    let mut bot = Bot::new(depth, tt_size, max_time);
    let m = bot.make_move(board.0, difficulty == Difficulty::Hard);

    return select_move(m, difficulty);
}
\end{lstlisting}

Structura \textit{Bot}
\begin{lstlisting}[language=RustHtml]
pub struct Bot {
    depth: i32,

    transposition_table: TranspositionTable,
    zobrist: Zobrist,

    time: u64,
    should_stop: bool,
    start: Instant,

    pv_table: Vec<Box<[Move]>>,
    pv_len: Vec<usize>,
}
\end{lstlisting}

Funcția \textit{make\_move} definită pentru un bot returnează un array care poate să conțină:
\begin{itemize}
	\item Un singur element: cea mai bună mutare, dacă este setată dificultatea grea
	\item Toate mutările legale din poziția inițială, sortate după scor, pentru celelate
	      dificultăți
\end{itemize}

\begin{lstlisting}[language=RustHtml]
pub fn make_move(&mut self, board: Board, hard_diff: bool) -> Box<[(Move, i32)]> {
    if hard_diff {
        let mut moves = vec![];
        self.start = Instant::now();
        for depth in 1..=self.depth {
            let s = self.search(board.clone(), -500_000, 500_000, depth, 0, true);
            self.reached_depth = depth;
            if self.should_stop {
                break;
            }
            moves = vec![(self.pv_table[0][0], s)];
        }
        moves.into()
    } else {
        let mut moves = vec![];
        for depth in 1..=self.depth {
            let mut new_moves = vec![];
            let m = legal_moves(&board);
            for m in m.iter() {
                let mut board = board.clone();

                board.make_move(m);
                let score = -self.search(board, -500_000, 500_000, depth, 1, true);

                new_moves.push((m.clone(), score));
            }

            self.reached_depth = depth;
            if self.should_stop {
                break;
            }
            moves = new_moves;
        }
        moves.sort_by(|a, b| b.1.cmp(&a.1));
        moves.into()
    }
}
\end{lstlisting}

Celelalte funcții folosite în căutare, care implementează algoritmii și tehnicile prezentate
anterior:
\begin{lstlisting}[language=RustHtml]
pub fn search(
    &mut self,
    board: Board,
    mut alpha: i32,
    beta: i32,
    depth: i32,
    ply: i32,
    mut follow_pv: bool,
) -> i32 {
    self.nodes_searched += 1;
    if self.nodes_searched % 5000 == 0 {
        self.check_time();
        if self.should_stop {
            return 0;
        }
    }

    self.pv_len[ply as usize] = 1;

    if depth == 0 {
        return self.quiescence(board, alpha, beta, ply);
    }

    let hash = self.zobrist.hash(&board);
    if let Some(score) = self.transposition_table.probe(hash, depth, alpha, beta) {
        return score;
    }

    let moves = legal_moves(&board);
    if follow_pv {
        follow_pv = false;
        for m in moves.iter() {
            if m == &self.pv_table[ply as usize][0] {
                follow_pv = true;
                break;
            }
        }
    }

    let moves = self.sorted_moves(ply, &board, follow_pv);
    if moves.is_empty() {
        return if board.in_check { -490_000 + ply } else { 0 };
    }

    let mut tt_entry_kind = TranspositionKind::Alpha;

    let next_depth = if board.in_check { depth } else { depth - 1 };
    for m in moves.iter() {
        let mut b = board.clone();
        b.make_move(m);
        let score = -self.search(b, -beta, -alpha, next_depth, ply + 1, follow_pv);

        if self.should_stop {
            return 0;
        }

        if score >= beta {
            self.transposition_table
                .store(hash, depth, beta, TranspositionKind::Beta, *m);
            return beta;
        }

        if score > alpha {
            tt_entry_kind = TranspositionKind::Exact;
            alpha = score;

            let p = ply as usize;
            self.pv_table[p][0] = *m;
            for i in 0..self.pv_table[p + 1].len() {
                self.pv_table[p][i + 1] = self.pv_table[p + 1][i];
            }
            self.pv_len[p] = self.pv_len[p + 1] + 1;
        }
    }

    self.transposition_table.store(
        hash,
        depth,
        alpha,
        tt_entry_kind,
        self.pv_table[ply as usize][0],
    );

    alpha
}

fn check_time(&mut self) {
    let ms = Instant::now() - self.start;
    let ms = ms.as_millis() as u64;
    if ms >= self.time {
        self.should_stop = true;
    }
}

fn quiescence(&mut self, board: Board, mut alpha: i32, beta: i32, ply: i32) -> i32 {
    if self.nodes_searched % 5000 == 0 {
        self.check_time();
        if self.should_stop {
            return 0;
        }
    }

    let score = Self::evaluate(&board);
    if score >= beta {
        return beta;
    }
    alpha = alpha.max(score);

    let moves = self.sorted_moves(ply, &board, false);
    for m in moves.into_iter().filter(|m| m.capture()) {
        let mut b = board.clone();
        b.make_move(m);
        let score = -self.quiescence(b, -beta, -alpha, ply + 1);

        if self.should_stop {
            return 0;
        }

        if score >= beta {
            return beta;
        }
        alpha = alpha.max(score);
    }

    alpha
}

fn move_score(&self, ply: i32, m: &Move, board: &Board, score_pv: bool) -> i32 {
    if score_pv && m == &self.pv_table[ply as usize][0] {
        return 10_000;
    }

    if matches!(m.special(), Some(SpecialMove::EnPassant)) {
        return Self::capture_value(PieceKind::Pawn, PieceKind::Pawn);
    }

    if let Some(p) = board.piece(m.to().idx()) {
        Self::capture_value(m.piece().kind, p.kind)
    } else {
        0
    }
}

fn sorted_moves(&self, ply: i32, board: &Board, score_pv: bool) -> Box<[Move]> {
    let moves = legal_moves(board);
    let mut moves = moves
        .into_iter()
        .map(|m| (m, self.move_score(ply, m, board, score_pv)))
        .collect::<Vec<_>>();
    moves.sort_by(|a, b| b.1.cmp(&a.1));
    moves.into_iter().map(|(m, _)| *m).collect()
}

fn capture_value(p1: PieceKind, p2: PieceKind) -> i32 {
    10 * Self::piece_value(p2) - Self::piece_value(p1)
}
\end{lstlisting}

Funcția \textit{select\_move} folosită în \textit{bot\_move} selectează care dintre mutările
returnate de structura \textit{bot} să fie jucată în funcție de dificultate:
\begin{itemize}
	\item Pentru ușor și mediu:
	      \begin{enumerate}
		      \item În cazul în care prima mutare are scorul foarte mare (algoritmul a găsit
		            o serie de mutări care duce la mat forțat) este aleasă aceasta
		      \item Altfel pentru fiecare mutare este calculat diferența dintre scorul acesteia și
		            scorul primei mutări
		      \item Se alege la întâmplare, cu probabilitățiile setate pentru fiecare dificultate
		            care să fie diferența maximă de scor dintre mutarea care va fi jucată și cea mai
		            bună mutare, apoi se alege una dintre mutările care nu depășeste diferența
	      \end{enumerate}
	      Astfel pe aceste dificultăți se vor juca intenționat mutări mai slabe pe lângă limitele
	      mai restrânse de timp și adâncime.

	\item Pentru greu este returnată o singură mutare care se returnează mai departe
\end{itemize}

\begin{lstlisting}[language=RustHtml]
fn select_move(moves: Box<[(Move, i32)]>, difficulty: Difficulty) -> Move {
    match difficulty {
        Difficulty::Easy => {
            if moves[0].1 >= 400_000 {
                return moves[0].0.into();
            }

            let score_brackets = [50, 100, 200, 500, 2000];
            let probabilites = [0.35, 0.25, 0.2, 0.15, 0.05];

            let moves_per_bracked: Vec<_> = score_brackets
                .iter()
                .map(|b| {
                    moves
                        .iter()
                        .filter(|(_, s)| moves[0].1 - *s <= *b)
                        .collect::<Vec<_>>()
                })
                .collect();

            loop {
                let mut r: f64 = rand::thread_rng().gen();
                console_log!("Generated {r}");
                let mut bracket = 0;
                for i in 0..probabilites.len() {
                    r -= probabilites[i];
                    bracket = i;
                    if r <= 0. {
                        break;
                    }
                }

                if !moves_per_bracked[bracket].is_empty() {
                    let idx = rand::thread_rng().gen_range(0..moves_per_bracked[bracket].len());
                    return moves[idx].0;
                }
            }
        }
        Difficulty::Medium => {
            if moves[0].1 >= 400_000 {
                return moves[0].0.into();
            }

            let score_brackets = [20, 50, 100, 200, 400];
            let probabilites = [0.5, 0.3, 0.1, 0.08, 0.02];

            // ...
            // Acelasi cod ca la dificulatea easy
        }
        Difficulty::Hard => moves[0].0;
    }
}
\end{lstlisting}
